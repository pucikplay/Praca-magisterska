\chapter{Eksperyment zerowy}\label{chap:experiment_zero}

Po przygotowaniu komponentów systemu wstępnie zaimplementowano program rozwiązujący problem multilateracji, aby zbadać, czy problem nie jest zbyt trywialny, aby opisać go w pracy, lub przeciwnym razie, na podstawie wyników eksperymentu zastanowić się jakie przeszkody stoją na drodze do rozwiązania o zadowalającej precyzji.

\section{Opis działania}

Program zaimplementowano na podstawie rozwiązania aproksymacyjnego równania \ref{eq:matrix} postaci

\begin{equation}
    \label{eq:lls}
    \hat{\boldsymbol{x}} = {\left(A^T A\right)}^{-1} A^T \boldsymbol{b}
\end{equation}

za pomocą metody najmniejszych kwadratów zaczerpniętej z artykułu~\cite{norrdine2012algebraic}. Współrzędne odbiorników są znane.

\subsection{Program węzła}

\begin{algorithm}
\caption{Program nadajnika}\label{alg:source}
\begin{algorithmic}[1]
    \State\ $buzz \gets False$
    \State\ $buzzTime \gets 0$
    \State\ $lastBuzzTime \gets 0$
    \State\ $syncTime \gets 0$

    \Function{onMessage}{$message, topic$}
        \If{$topic$ is $TOPIC$}
            \State\ $buzz \gets message$
        \EndIf
        \If{$topic$ is $TIME\_TOPIC$}
            \State\ $syncTime \gets micros()$
        \EndIf
    \EndFunction

    \Loop
        \If{$buzz$ and $micros() - lastBuzzTime > BUZZ\_INTERVAL$}
            \State\ $buzzTime \gets micros() - syncTime$
            \State\ $publish(buzzTime)$
            \State\ $lastBuzzTime \gets buzzTime$
            \State\ $buzzer()$
        \EndIf
    \EndLoop
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Program odbiornika}\label{alg:sink}
\begin{algorithmic}[1]
    \State\ $micState \gets LOW$
    \State\ $micTime \gets False$
    \State\ $lastMicTime \gets 0$
    \State\ $syncTime \gets 0$

    \Function{onMessage}{$topic$}
        \If{$topic$ is $TIME\_TOPIC$}
            \State\ $syncTime \gets micros()$
        \EndIf
    \EndFunction

    \Function{micInterrupt}{}
        \State\ $micState \gets HIGH$
    \EndFunction

    \Loop
        \If{$micState$ is $HIGH$ and $micros() - lastMicTime > MIC\_INTERVAL$}
            \State\ $micTime \gets micros() - syncTime$
            \State\ $publish(micTime)$
            \State\ $lastMicTime \gets micTime$
            \State\ $micState \gets LOW$
        \EndIf
    \EndLoop
\end{algorithmic}
\end{algorithm}

\begin{itemize}
    \item $micros()$ {-} funkcja zwracająca liczbę mikrosekund od uruchomienia urządzenia,
    \item $TOPIC$ {-} nazwa kanału MQTT korespondującego do danego węzła,
    \item $TIME\_TOPIC$ {-} nazwa kanału MQTT służącego do przesyłania wiadomości o synchronizacji czasu.
    \item $publish()$ {-} funkcja publikująca wiadomość na zadanym kanale MQTT
\end{itemize}

\subsection{Program serwera}

\begin{algorithm}
\caption{Program serwera}\label{alg:server}
\begin{algorithmic}[1]
    \State\ $M \gets {\left(A^T A\right)}^{-1} A^T$
    \Function{$calc\_position$}{}
        \For{$node$ in $NODES$}
            \State\ $d \gets (SS / 10^{6}) \cdot time(node) - time(source)$
            \State\ $b_{node} \gets d - \sum{coords(node)^2}$
        \EndFor
        \State\ return $M \cdot b$
    \EndFunction
    \Loop{ $main$}
        \State\ $sleep(t_1)$
        \State\ $calc\_position()$
    \EndLoop
    \Loop{ $sync\_clock$}{}
        \State\ $publish(TIME\_TOPIC)$
        \State\ $sleep(t_2)$
    \EndLoop
\end{algorithmic}
\end{algorithm}

\begin{itemize}
    \item $A$ - macierz zawierająca współrzędne obiorników z równania \ref{eq:matrix}
    \item $SS$ {-} prędkość dźwięku $\left[\frac{m}{s}\right]$,
    \item $time()$ {-} czas dostarczony w ostatniej wiadomości od węzła,
    \item $coords()$ {-} współrzędne węzła,
    \item $t_1$ {-} czas pomiędzy obliczeniami pozycji,
    \item $t_2$ {-} czas pomiędzy wiadomościami synchronizującymi zegary.
\end{itemize}

\subsection{Opis algorytmu}

W programie serwera zaimplementowano funkcję rozwiązującą równość~\ref{eq:lls} przy pomocy funkcji bibliotecznych dostępnych w pakiecie \texttt{numpy}. Jak łatwo zauważyć pierwsza część lewej strony równości zależy jedynie od macierzy $A$, która nie zawiera zmiennych związanych z węzłem źródłowym, co pozwala na wcześniejsze i jednorazowe przeprowadzenie kosztownych przekształceń tej macierzy. W tej sytuacji jednorazowe wywołanie funkcji wymaga jedynie obliczenia wektora $b$ oraz iloczynu skalarnego. Wywołania następują co interwał $t_1$. Co interwał $t_2$ serwer wysyła wiadomość synchronizującą z założeniem, że węzły odbierają ją równocześnie i w ten sposób synchronizują zegary.

\section{Ewaluacja działania systemu}

Pierwsze testy przeprowadzone zostały na systemie operującym w jednym wymiarze (to jest wszystkie węzły są współliniowe) w celu jak największego uproszczenia, pozwalającego na szybsze wykrywanie i rektyfikację błędów. Wszystkie odległości będą podawane w metrach.

\subsection{Struktura systemu testowego}

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[pointnode/.style={circle, fill=black}, node distance=5cm, minimum size=5mm]
        \node[pointnode,
              label=above:{Nadajnik},
              label=below:{$0$}] (N) {};
        \node[pointnode,
              label=above:{Odbiornik 1.},
              label=below:{$-0.5$}] (O1) [left=of N] {};
        \node[pointnode,
              label=above:{Odbiornik 2.},
              label=below:{$0.5$}] (O2) [right=of N] {};
        \draw[-, thin, dotted] (-8,0) -- (8,0);
    \end{tikzpicture}
    \caption{Układ systemu testowego}
\label{fig:test_setup}
\end{figure}

Nadajnik umiejscowiono w punkcie $(0)$, natomiast dwa odbiorniki w punktach odpowiednio $(-0.5)$ i $(0.5)$, wszystkie węzły były stacjonarne. Nadajnik co $0.5$ $s$ nadawał sygnał o długości $10$ $ms$, a serwer co $0.5$ $s$ zwracał wynik zagadnienia multilateracji na podstawie ostatnio otrzymanych danych. Wykonano 5 następujących bezpośrednio po sobie eksprymentów, poniżej przedstawiono wyniki trzech pierwszych, ponieważ są wystarczające do ukazania zachodzącego trendu.

\begin{figure}[h]
\centering
    \includegraphics[scale=0.6]{pics/position/position_0.png}
\caption{Wykres obliczonej pozycji odbiornika w zależności od czasu}
\label{fig:position_0}
\end{figure}

\begin{figure}[h]
\centering
    \includegraphics[scale=0.6]{pics/position/position_1.png}
\caption{Wykres obliczonej pozycji odbiornika w zależności od czasu}
\label{fig:position_1}
\end{figure}

\begin{figure}[h]
\centering
    \includegraphics[scale=0.6]{pics/position/position_2.png}
\caption{Wykres obliczonej pozycji odbiornika w zależności od czasu}
\label{fig:position_2}
\end{figure}

% \begin{figure}[h]
% \centering
%     \includegraphics[scale=0.6]{pics/position/position_3.png}
% \caption{Wykres obliczonej pozycji odbiornika w zależności od czasu}
% \label{fig:position_2}
% \end{figure}

\section{Interpretacja wyników i wnioski}

Już na pierwszym z wykresów widać, że wartości wyjściowe algorytmu są niestabilne, współrzędna nadajnika wacha się w przedziale $(-0.98, -0.8)$, a także co jakiś czas następują nagłe przeskoki między następującymi po sobie wartościami. Coraz większa rozbieżność następuje wraz z upływem czasu. Już w drugim teście różnica ekstremalnych odchyleń jest większa niż odległość między nadajnikami, a dokładność jest absolutnie niezadowalająca. Kolejne testy jedynie utwierdzają te obserwacje.

Na niską dokładność i stabilność wyników może mieć wpływ wiele czynników takich jak:

\begin{itemize}
    \item niepoprawna synchronizacja zegarów węzłów,
    \item niepoprawna kalibracja czułości mikrofonów,
    \item fałszywe odczyty wynikające z odbić fali dźwiękowej,
    \item niska jakość rozwiązania aproksymacyjnego.
    \item TODO
\end{itemize}

Obserwując skoki pomiędzy sąsiadującymi obserwacjami położenia rozdzielającymi okresy względnej stabilności i mając na uwadze statyczność otoczenia systemu możemy śmiało wysnuć wniosek, że tak nagła zmiana średniej obliczanej wartości może wynikać najprawdopodobniej z błędnej synchronizacji czasu. Wygląda na to, że sygnał wysyłany przez serwer obliczeniowy nie jest odbierany we wszystkich węzłach równocześnie. Następny rozdział będzie poświęcony badaniu i tworzeniu algorytmu synchronizacji zegarów w węzłach.