\chapter{Eksperyment zerowy}

Po przygotowaniu komponentów systemu wstępnie zaimplementowano program rozwiązujący problem multilateracji, aby zbadać, czy problem nie jest zbyt trywialny, aby opisać go w pracy, lub przeciwnym razie, na podstawie wyników eksperymentu zastanowić się jakie przeszkody stoją na drodze do rozwiązania o zadowalającej precyzji.

\section{Opis działania}

Program zaimplementowano na podstawie rozwiązania aproksymacyjnego równania \ref{eq:matrix} postaci

\begin{equation}
    \label{eq:lls}
    \hat{\boldsymbol{x}} = {\left(A^T A\right)}^{-1} A^T \boldsymbol{b}
\end{equation}

za pomocą metody najmniejszych kwadratów zaczerpniętej z artykułu~\cite{norrdine2012algebraic}.

\subsection{Program węzła}

\begin{algorithm}
\caption{Program nadajnika}\label{alg:source}
\begin{algorithmic}[1]
    \State\ $buzz \gets False$
    \State\ $buzzTime \gets 0$
    \State\ $lastBuzzTime \gets 0$
    \State\ $syncTime \gets 0$

    \Function{onMessage}{$message, topic$}
        \If{$topic$ is $TOPIC$}
            \State\ $buzz \gets message$
        \EndIf
        \If{$topic$ is $TIME\_TOPIC$}
            \State\ $syncTime \gets micros()$
        \EndIf
    \EndFunction

    \Loop
        \If{$buzz$ and $micros() - lastBuzzTime > BUZZ\_INTERVAL$}
            \State\ $buzzTime \gets micros() - syncTime$
            \State\ $publish(buzzTime)$
            \State\ $lastBuzzTime \gets buzzTime$
            \State\ $buzzer()$
        \EndIf
    \EndLoop
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Program odbiornika}\label{alg:sink}
\begin{algorithmic}[1]
    \State\ $micState \gets LOW$
    \State\ $micTime \gets False$
    \State\ $lastMicTime \gets 0$
    \State\ $syncTime \gets 0$

    \Function{onMessage}{$topic$}
        \If{$topic$ is $TIME\_TOPIC$}
            \State\ $syncTime \gets micros()$
        \EndIf
    \EndFunction

    \Function{micInterrupt}{}
        \State\ $micState \gets HIGH$
    \EndFunction

    \Loop
        \If{$micState$ is $HIGH$ and $micros() - lastMicTime > MIC\_INTERVAL$}
            \State\ $micTime \gets micros() - syncTime$
            \State\ $publish(micTime)$
            \State\ $lastMicTime \gets micTime$
            \State\ $micState \gets LOW$
        \EndIf
    \EndLoop
\end{algorithmic}
\end{algorithm}

\begin{itemize}
    \item $micros()$ {-} funkcja zwracająca liczbę mikrosekund od uruchomienia urządzenia,
    \item $TOPIC$ {-} nazwa kanału MQTT korespondującego do danego węzła,
    \item $TIME\_TOPIC$ {-} nazwa kanału MQTT służącego do przesyłania wiadomości o synchronizacji czasu.
\end{itemize}

\subsection{Program serwera}

\begin{algorithm}
\caption{Program serwera}\label{alg:server}
\begin{algorithmic}[1]
    \State\ $M \gets {\left(A^T A\right)}^{-1} A^T$
    \Function{$calc\_position$}{}
        \For{$node$ in $NODES$}
            \State\ $d \gets (SS / 10^{6}) \cdot time(node) - time(source)$
            \State\ $b_{node} \gets d - \sum{coords(node)^2}$
        \EndFor
        \State\ return $M \cdot b$
    \EndFunction
    \Loop{ $main$}
        \State\ $sleep(t_1)$
        \State\ $calc\_position()$
    \EndLoop
    \Loop{ $sync\_clock$}{}
        \State\ $publish(TIME\_TOPIC)$
        \State\ $sleep(t_2)$
    \EndLoop
\end{algorithmic}
\end{algorithm}

\begin{itemize}
    \item $A$ - macierz zawierająca współrzędne obiorników z równania \ref{eq:matrix}
    \item $SS$ {-} prędkość dźwięku $\left[\frac{m}{s}\right]$,
    \item $time()$ {-} czas dostarczony w ostatniej wiadomości od węzła,
    \item $coords()$ {-} współrzędne węzła,
    \item $t_1$ {-} czas pomiędzy obliczeniami pozycji,
    \item $t_2$ {-} czas pomiędzy wiadomościami synchronizującymi zegary.
\end{itemize}

\subsection{Opis algorytmu}

W programie serwera zaimplementowano funkcję rozwiązującą równość~\ref{eq:lls} przy pomocy funkcji bibliotecznych dostępnych w pakiecie \texttt{numpy}. Jak łatwo zauważyć pierwsza część lewej strony równości zależy jedynie od macierzy $A$, która nie zawiera zmiennych związanych z węzłem źródłowym, co pozwala na wcześniejsze i jednorazowe przeprowadzenie kosztownych przekształceń tej macierzy. W tej sytuacji jednorazowe wywołanie funkcji wymaga jedynie obliczenia wektora $b$ oraz iloczynu skalarnego. Wywołania następują co interwał $t$.

\section{Ewaluacja działania systemu}

\subsection{Struktura systemu testowego}

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[circlenode/.style={circle, draw=black}, node distance=3cm, thick]
        \node[circlenode] (N) {Nadajnik};
        \node[circlenode] (O1) [left=of N] {Odbiornik 1.};
        \node[circlenode] (O2) [right=of N] {Odbiornik 2.};
        \draw[-, thin, dotted] (O1) to (O2);
    \end{tikzpicture}
    \caption{Układ systemu testowego}
\label{fig:test_setup}
\end{figure}

Pierwsze testy przeprowadzone zostały na systemie operującym w jednym wymiarze (to jest wszystkie węzły są współliniowe) w celu jak największego uproszczenia, pozwalającego na szybsze wykrywanie i rektyfikację błędów.

\section{Interpretacja wyników i wnioski}